title: 第一章 Git
date: 2018-2-4 1:25:12
categories: 编程基础
---
　　最近一段时间笔者Git使用比较多，由于没有系统的学习，一直拿Git当做另一个SVN使用，正好趁着最近有时间完整的整理一下，同时加深印象。
<!-- more -->
## Git介绍 ##
　　最初Git 是 Linus Torvalds(`Linux的开发者`) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。
　　
　　它采用了分布式版本库的方式，对服务器端软件依赖较小，每个人的电脑都是一个Git版本仓库，使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说很重要。 Git 最为出色的是它的合并跟踪能力。
　　
　　对于Git的出现这里有个故事，大家有兴趣的可以看一下[Git的由来][1]。
### Git与SVN ###
　　由于SVN等工具出现的年头很长了，包括笔者在工作中使用的一直都是SVN，我么这里就简单聊一下Git与SVN的一些差异。
　　核心不同点：

	-  SVN是集中式的，各个客户端共同维护一个代码库，开发时需要联网才能提交代码到代码库。
	-  Git是分布式的，各个客户端虽然仍然是共同维护一个代码库，但是每个客户端在下载代码时，会同时在本地建立代码库副本，就算开发者没有网络，开发者也可以肆无忌惮的工作，在处于重要的工作节点时可以对本地的代码库进行add、commit等操作。

　　Git会在本地创建代码库的特性，确实给开发者带来了好处：

	-  当没有网络时,Git依然可以进行提交操作,并有完整提交记录，不必担心工作过程丢失，而svn在没有网络时虽然也可以在本地工作,但是这就像写word文档而无法保存一样危险。

<br>　　关于Git与SVN其他的不同点就不多说了，大家可以参考[解读Git与SVN的区别][2]。

## 基础入门 ##
### Git的安装 ###
　　本章是基于Windows系统，需要在其他系统安装请参考[这里][3]。
　　
　　首先你可以试着输入`git`，看当前系统有没有安装。
　　如果没有安装，可以从Git官网直接[下载安装程序][4]，（网速慢的同学请移步[国内镜像][5]），然后按默认选项安装即可。
　　安装完成后，在开始菜单里找到“Git”->“Git Bash”，弹出一个类似命令行窗口的东西，就说明Git安装成功！
　　![Git bash][6]
　　安装完成，还需要最后一步设置，在命令行输入：
``` git
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
```
- 注意`git config`命令的`--global`参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。

### Git基本操作 ###
　　创建一个名为`gittest`的目录，然后在Git Bash中进入到该目录下。
#### 创建本地版本库 ####
``` git
git init
```
    语句解释：
    -  此命令创建了一个新的本地版本库或初始化一个现有仓库。
    -  命令执行之后，gittest目录下会出现一个名为.git的隐藏目录，里面保存着各类信息，请不要手工修改其内的任何文件。
    -  在现有仓库中执行git init是安全的，它不会覆盖已有的文件。

<br>　　然后再创建一个`test1.txt`，并将`1111`写入到文件中。
#### 查看本地版本库状态 ####
``` git
miss@faraway MINGW64 /d/gitwork/gitest (master)$ git status
位于分支 master

初始提交

未跟踪的文件:
  （使用 "git add <file>..." 以包含要提交的内容）

	test1.txt

提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪）
```
    语句解释：
    -  “未跟踪的文件”是指未被纳入到版本控制中，也就是说如果我们此时执行提交命令，是不会将a.txt添加到版本库中的。
#### 添加到版本库 ####
``` git
git add test1.txt
```
    语句解释：
    -  使用add命令就可以将指定的文件加入到版本库的控制中。
    -  然后再次执行git status命令就可以看到git提示test1.txt已经被加入到版本控制中了。

#### 批量添加到版本库 ####
``` git
git add -A
```
    语句解释：
    -  在add命令之后加上-A参数就可以递归的将当前以及当前子目录下的所有文件纳入到版本控制中。

#### 提交代码 ####
``` git
git commit -m "提交"
```
    语句解释：
    -  这是最简单的提交命令，执行后就可以将我们刚才新增的文件提交到版本库中。
    -  -m后面是本次提交的说明，你可以从提交历史中看到它。

<br>　　出于谨慎起见，在正式开发时，我们通常在提交代码之前都会再检查一遍自己所有修改的文件，看看有没有什么问题。但是如果代码改的比较多，在提交的时候就很容易忘了自己之前改了哪些代码。
　　在Git中可以使用命令来查看改动，比如我们现在把`test1.txt`的内容修改为`2222`，并保存。
#### 比较文件 ####
``` git
miss@faraway MINGW64 /d/gitwork/gitest (master)$ git diff test1.txt

diff --git a/test1.txt b/test1.txt
index 5f2f16b..c7dc989 100644
--- a/test1.txt
+++ b/test1.txt
@@ -1 +1 @@
-1111
+2222

```
    语句解释：
    -  使用“git diff 文件名”就可以查看指定文件的改动情况。
    -  减号表示删除的行，加号表示增加的行。

<br>　　代码提交完毕后，还可以用`git log`命令查看提交记录。
#### 查看提交记录 ####
``` git
miss@faraway MINGW64 /d/gitwork/gitest (master)$ git log

commit 78ab9b610de9a13288fd8f82127d297c8add418e (HEAD -> master)
Author: faraway96 <xxx@qq.com>
Date:   Sun Feb 4 12:47:27 2018 +0800

    123

commit 92c9cd9558a618f183d347cca62604df08041167
Author: faraway96 <xxx@qq.com>
Date:   Sun Feb 4 12:42:26 2018 +0800

    1

```
    语句解释：
    -  如果嫌输出信息太多，看得眼花缭乱的，可以在命令后面加上--pretty=oneline参数。
    -  需要注意的是，上面那一大串类似78ab9b61...418e的是commit id（版本号）。
    -  和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。而且你看到的commit id和我的肯定不一样，以你自己的为准。
    -  为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，如果大家都用1，2，3……作为版本号，那肯定就冲突了。

<br>　　很多时候执行完commit之后就会后悔，Git也给了我们反悔的机会。
　　在Git中，用`HEAD`表示当前版本，也就是上面的78ab9b...418e（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个^比较容易数不过来，所以写成`HEAD~100`。
#### 撤销提交 ####
``` git
git reset --hard HEAD^
```
    语句解释：
    -  使用reset命令就可以将当前版本库还原到指定的版本中，当前这个指令就是还原到上个版本，此时你再打开test1.txt就会发现里面的数字变成1111了。
    -  其中--hard的作用稍后介绍。

<br>　　如果再还原之后，你又后悔了，想还原到刚才`2222`的那个版本，那也可以。
#### 查看执行的操作历史 ####
``` git
miss@faraway MINGW64 /d/gitwork/gitest (master)$ git reflog

92c9cd9 (HEAD -> master) HEAD@{0}: reset: moving to HEAD^
78ab9b6 HEAD@{1}: commit: 123
92c9cd9 (HEAD -> master) HEAD@{2}: commit: 1
4d8eef0 HEAD@{3}: commit (initial): 提交
```
    语句解释：
    -  Git提供了一个命令git reflog用来记录你的每一次命令。
    -  从这个记录中我们可以看到版本库编号的前半部分（回滚时只要输入版本号的前缀git就可以知道要恢复到哪个版本上了）。
    -  也就是说，只需要执行“git reset --hard 78ab9b6”就能将内容还原到2222。
    -  Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向目标版本。

#### 工作区和暂存区 ####
　　这里介绍一下工作区与暂存区的概念：

	-  工作区：就是我们自己文件的所在目录，比如test1.txt的所在目录。

	-  暂存区：暂存区就是.git文件夹下的index（或者叫stage）,暂存区是git中很重要的一个概念，当我们对文件进行提交时有两步操作
    	-  第一步执行git add操作，add实际就是把文件添加到了暂存区。
    	-  第二步执行git commit操作就是将暂存区的文件提交到了当前分支。

	-  版本库：版本库就是.git文件夹，里面存了很多东西，其中重要的就是暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。


#### 撤出缓存区 ####

　　总有时候我们把某个文件加入到缓存区之后就又后悔了，想把它撤出来。
``` git
git reset HEAD test1.txt
```
    语句解释：
    -  使用“git reset HEAD 文件名”就可以将该文件撤出缓存区。

#### 恢复文件到初始状态 ####
　　还有一种情况，我们在一个类中写了半天的代码，最后发现写了还不如不写，但是由于写的太多了，使用ctrl+z已经没法将文件退回到最初的状态了，此时我们同样有方法。
``` git
git checkout -- test1.txt
```
    语句解释：
    -  需要注意的是--和test1.txt之间是有空格存在的。
    
    -  checkout命令可以使本地文件回退，不过这其中有几点需要注意的地方。
        -  我们修改文件之后，如果将文件已经添加到了暂存区，那么进行checkout操作只会将本地文件重置为暂存区中的文件。
        -  这个时候如果我们想重置为版本库中文件的话，就需要将文件先撤出暂存区再进行checkout操作。

<br>　　当我们不需要某个文件时，可以直接在目录中将它给删除，这个时候Git知道你删除了文件，因此工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了。
　　此时你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且提交。
　　另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本。

## 远程仓库 ##
### 远程仓库介绍 ###
　　我们上面所说的都是操作的本地版本库，这节我们就开始和网络关联起来了，我们开发项目的时候离不开团队协作。

    -  使用SVN的时候是有中央版本仓库，大家通过下载、上传代码的方式进行开发。
    
    -  使用Git也是有一个Git远程仓库，大家通过clone的方式将远程仓库克隆到本地，在本地版本库进行开发工作，完成之后再推送到远程仓库，同时也可以拉取别人提交的内容。

　　对于Git的远程仓库，我们可以在服务器上自己搭建，像一些公司对代码的安全性和保密性要求较高的，就会搭建自己的git服务器。
　　或者使用第三方的git仓库。目前常见的仓库有：Github、CSDN、开源中国等等，它们各有各的特点。
<br>　　不论你是使用自己的Git库还是第三方的，想成功从git远程仓库中下载和上传代码，一般都需要经历如下几个步骤：

	-  首先，去git服务器注册一个账号。
	-  第二，在本地创建你自己的ssh秘钥，并把公钥配置到git服务器中。
	-  第三，当你从git服务器下载或上传代码时，服务器就会通过公钥来验证你的身份。

<br>　　至于如何创建ssh密钥，网上有很多教程，[ 这里 ](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137628548491051ccfaef0ccb470894c858999603fedf000)是以Github为例介绍了配置步骤，如果觉得不详细可以自行搜索。

### 基本操作 ###
　　首先你在Github上应该已经有了一个远程仓库，没有的话就先去建一个吧。
#### 克隆远程仓库 ####

　　在`d`盘新建一个目录`gittest`，打开Git Bash
```git
git clone git@github.com:faraway96/gittest.git
```
    语句解释：
    -  clone命令会将GitHub上远程仓库gittest克隆到本地，克隆之后你就可以开心的工作了。
#### 推送到远程仓库 ####

　　修改目录`gittest`下的文件内容，`git add`并且`git commit`
```git
git push
```
    语句解释：
    -  clone命令会将GitHub上远程仓库gittest克隆到本地，克隆之后你就可以开心的工作了。
　　然后去GitHub查看一下，修改的内容是不是已经推送到远程仓库了。
　　分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！
## 分支管理 ##
　　在Git里，在创建仓库的同时会创建一个分支，这个分支叫主分支，即`master`分支。
　　另外，`HEAD`严格来说是指向当前分支，即默认情况下`HEAD`指向的是`master`。

　　当我们创建新的分支例如`dev`时，Git会同时新建了一个指针叫`dev`，它指向与`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上。

<br>　　范例1：创建分支。
``` git
git checkout -b dev
```
    语句解释：
    -  使用上面这条命令就可以创建并切换到dev分支，它相当于连续执行了下面两条语句：
       -  创建分支：git branch dev
       -  切换分支：git checkout dev
    -  执行“git checkout”命令可以列出所有的分支，其中当前分支前面会标一个*号。

<br>　　需要知道的是，我们在dev分支上执行的操作（add、commit等）不会影响到其它分支。
　　比如我们在dev分支中添加一个b.txt，然后提交，确保提交成功后再切回到master分支，然后你就会发现在文件夹中是看不到b.txt的。

<br>　　范例2：合并分支。
``` git
cutler@cutler-OptiPlex-7040:~/workspace/gittest$ git merge dev
更新 2e61159..2474a7b
Fast-forward
 b.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 b.txt
```
    语句解释：
    -  git merge命令用于合并指定分支到当前分支。合并后，就可以在目录中看到b.txt了。
    -  注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。
    -  当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。

<br>　　合并完成后，就可以放心地删除dev分支了。
　　范例3：删除分支。
``` git
git branch -d dev
```
    语句解释：
    -  如你所见。

<br>　　开发中的情况往往会更加复杂，如果master和dev分支同时修改了1个文件，那么合并时就会出现冲突。
　　这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。
　　范例4：合并分支时产生冲突。
``` git
cutler@cutler-OptiPlex-7040:~/workspace/gittest$ git merge dev1
自动合并 b.txt
冲突（内容）：合并冲突于 b.txt
自动合并失败，修正冲突然后提交修正的结果。
```
    语句解释：
    -  Git告诉我们，readme.txt文件存在冲突，需要手动解决冲突后再提交。

<br>　　我们可以直接打开b.txt并查看它的内容：
``` git
<<<<<<< HEAD
Creating a new branch is quick & simple.
=======
Creating a new branch is quick AND simple.
>>>>>>> dev1
```
    语句解释：
    -  Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容。
    -  解决冲突的办法也很简单，只需要打开这个文件，把你不想保留的内容给删掉就可以了。
    -  接着就是执行add命令将文件添加到缓存区，最后是commit。


<br>　　现在有这么一个问题：

	-  你现在正在开发新版本的功能，但是突然分配给你一个紧急的bug，而你由于手头上的代码没有完成（比如逻辑没写完或者还存在编译错误等），立刻提交的话肯定是不行的。
	-  但是bug也是非常紧急的，需要立刻去处理。
	-  为了解决这个问题，Git提供了stash命令，它可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。

<br>　　通常情况下，我们会在dev分支上开发新功能，而master分支保存的是稳定版的代码，主要用来打包用的。因此为了解决bug，我们会以master分支为基础，创建一个新的bug分支。
　　更多关于bug分支的介绍可以看[ 这里 ](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000)，唯一需要补充的就是：

	-  如果我们在dev分支下添加了新的文件，那么不论这个新文件是否被加入到版本控制中。
	-  当我们把分支从dev切换到其他分支时，这些文件都不会消失（除非它们被提交到某个分支上了）。
	-  这样一来就会乱了，开发一段时间后，我们不知道这个文件应该保存到哪个分支下。
	-  所以，在我们准备从dev分支切走之前，执行一下git stash命令就可以保存现存，切换分支时与新增的文件也会随之消失。
	-  还原分支可以使用：git stash pop命令。
	-  查看分支列表可以使用：git stash list。

<br><br>

**本篇参考阅读：**
- [不只是看客](http://cutler.github.io/base-03/)
- [廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

　　


  [1]: https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000
  [2]: http://blog.csdn.net/hellow__world/article/details/72529022
  [3]: https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000
  [4]: https://git-scm.com/downloads
  [5]: https://pan.baidu.com/s/1kU5OCOB#list/path=/pub/git
  [6]: /img/codebase1-1.jpg